# [Gold I] 벽 부수고 이동하기 3 - 16933 

[문제 링크](https://www.acmicpc.net/problem/16933) 

### 성능 요약

메모리: 52700 KB, 시간: 616 ms

### 분류

너비 우선 탐색, 그래프 이론, 그래프 탐색

### 제출 일자

2024년 8월 22일 18:57:20

### 문제 설명

<p>N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. 이동하지 않고 같은 칸에 머물러있는 경우도 가능하다. 이 경우도 방문한 칸의 개수가 하나 늘어나는 것으로 생각해야 한다.</p>

<p>이번 문제에서는 낮과 밤이 번갈아가면서 등장한다. 가장 처음에 이동할 때는 낮이고, 한 번 이동할 때마다 낮과 밤이 바뀌게 된다. 이동하지 않고 같은 칸에 머무르는 경우에도 낮과 밤이 바뀌게 된다.</p>

<p>만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다. 단, 벽은 낮에만 부술 수 있다.</p>

<p>한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.</p>

<p>맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.</p>

### 출력 

 <p>첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.</p>

### 코멘트

 <p>벽 부수고 이동하기 1,2를 이어서 3이다. 2에서는 언제나 벽을 뚫을 수 있었는데 3에서는 낮과 밤이 생겨 낮에만 벽을 뚫을 수 있게 됐다. 또한 밤에는 벽을 뚫을 수 없다보니 가만히 서있다는 선택지도 생겼다. 거의 3시간에 걸려 푼거같은데 처음에는 while문 돌때마다 낮밤이 바뀌게 만들고 밤에는 벽 못뚫게 하면 금방 문제를 풀줄 알았지만 오산이었다. bool day를 통해 토글 형식으로 만들었다가 안되서 큐안에 day를 넣어버렸다. 다른거 동일하게 하고 다시 토글형식으로 바꿔도 해결될진 모르겠다. 그 이후</p> 0100</p>
1110</p>1000의 형태에서 (1,0)에 있을 때 아래로 갈때나 오른쪽으로 갈때 밤상태에서 기다려야하니 (1,0)의 vis값을 1늘리게 된다. 하지만 그래야 하는 경우가 지금 2번 필요하니 거리가 2번 늘어나는것을 방지가능하게 하였으며 (0,2)에서 아래로 갈경우 기다려야하니 (0,2)의 vis값이 1늘어나고 오른쪽으로 갈경우 늘어날필요 없이 그냥 가면 된다. 하지만 (0,2)의 vis값을 그대로 이용해 오른쪽으로 갈려하면 (0,2)의 vis값이 1늘어난 상태라 오른쪽의 vis값을 2 늘려버리는 현상이 발생했다. 이를 해결할려고 그냥 큐에 거리값도 같이 넣어줬으며 이럼 vis도 편하게 늘리고 오른쪽으로 진행시 vis를 1만 늘리는게 가능했다.<p>
 

